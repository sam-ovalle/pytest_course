Index: cards_proj_with_bugs/src/cards/api.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nAPI for the cards project\n\"\"\"\nfrom __future__ import annotations\nfrom dataclasses import asdict\nfrom dataclasses import dataclass\nfrom dataclasses import field\n\nfrom .db import DB\n\n__all__ = [\n    \"Card\",\n    \"CardsDB\",\n    \"CardsException\",\n    \"MissingSummary\",\n    \"InvalidCardId\",\n]\n\n\n@dataclass\nclass Card:\n    summary: str | None = None\n    owner: str | None = None\n    state: str | None = \"todo\"\n    id: int | None = field(default=None, compare=False)\n\n    @classmethod\n    def from_dict(cls, d):\n        return Card(**d)\n\n    def to_dict(self):\n        return asdict(self)\n\n\nclass CardsException(Exception):\n    pass\n\n\nclass MissingSummary(CardsException):\n    pass\n\n\nclass InvalidCardId(CardsException):\n    pass\n\n\nclass CardsDB:\n    def __init__(self, db_path):\n        self._db_path = db_path\n        self._db = DB(db_path, \".cards_db\")\n\n    def add_card(self, card: Card) -> int:\n        \"\"\"Add a card, return the id of card.\"\"\"\n        if not card.summary:\n            raise MissingSummary\n        if card.owner is None:\n            card.owner = \"\"\n        card_id = self._db.create(card.to_dict())\n        self._db.update(card_id, {\"id\": card_id})\n        return card_id\n\n    def get_card(self, card_id: int) -> Card:\n        \"\"\"Return a card with a matching id.\"\"\"\n        db_item = self._db.read(card_id)\n        if db_item is not None:\n            return Card.from_dict(db_item)\n        else:\n            raise InvalidCardId(card_id)\n\n    def list_cards(self, owner=None, state=None):\n        \"\"\"Return a list of cards.\"\"\"\n        all_cards = self._db.read_all()\n        if (owner is not None) and (state is not None):\n            return [\n                Card.from_dict(t)\n                for t in all_cards\n                if (t[\"owner\"] == owner and t[\"state\"] == state)\n            ]\n        elif owner is not None:\n            return [Card.from_dict(t) for t in all_cards if t[\"owner\"] == owner]\n        elif state is not None:\n            return [Card.from_dict(t) for t in all_cards if t[\"state\"] == state]\n        else:\n            return [Card.from_dict(t) for t in all_cards]\n\n    def count(self) -> int:\n        \"\"\"Return the number of cards in db.\"\"\"\n        return self._db.count()\n\n    def update_card(self, card_id: int, card_mods: Card) -> None:\n        \"\"\"Update a card with modifications.\"\"\"\n        try:\n            self._db.update(card_id, card_mods.to_dict())\n        except KeyError as exc:\n            raise InvalidCardId(card_id) from exc\n\n    def start(self, card_id: int):\n        \"\"\"Set a card state to 'in prog'.\"\"\"\n        self.update_card(card_id, Card(state=\"in prog\"))\n\n    def finish(self, card_id: int):\n        \"\"\"Set a card state to 'done'.\"\"\"\n        self.update_card(card_id, Card(state=\"done\"))\n\n    def delete_card(self, card_id: int) -> None:\n        \"\"\"Remove a card from db with given card_id.\"\"\"\n        try:\n            self._db.delete(card_id)\n        except KeyError as exc:\n            raise InvalidCardId(card_id) from exc\n\n    def delete_all(self) -> None:\n        \"\"\"Remove all cards from db.\"\"\"\n        self._db.delete_all()\n\n    def close(self):\n        self._db.close()\n\n    def path(self):\n        return self._db_path\n
===================================================================
diff --git a/cards_proj_with_bugs/src/cards/api.py b/cards_proj_with_bugs/src/cards/api.py
--- a/cards_proj_with_bugs/src/cards/api.py	
+++ b/cards_proj_with_bugs/src/cards/api.py	
@@ -83,6 +83,10 @@
         else:
             return [Card.from_dict(t) for t in all_cards]
 
+    def list_done_cards(self):
+        """Return a list of done cards."""
+        return_cards = self.list_cards(state="done")
+
     def count(self) -> int:
         """Return the number of cards in db."""
         return self._db.count()
